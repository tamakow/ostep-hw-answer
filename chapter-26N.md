# note of chapter 26

**multi-threaded** program : has more than one point of execution.

each thread is very much like a separate process, except for a difference: they *share* the same address space and thus can access the same data.

多线程的两个原因：

	* 并发
	* 防止IO操作引起的阻塞



## 26.1 一个例子：线程创建

线程创建有点像进行函数调用。然而，并不是首先执行函数然后返回给调用者，而是为被调用的例程创建一个新的执行线程，它可以独立于调用者运行，可能在从
创建者返回之前运行，但也许会晚得多。根据调度程序(scheduler)的决定，它们可能会以不同于创建线程的顺序运行



## 26.2 为什么更糟糕： 共享数据

当两个线程都向共享变量计数器添加1，并在循环中执行充分大次，最后发现往往得到一个不同于预期的数（例如，每个线程都向counter加1e7次1，可最后结果往往不是2e7而是一个小于其的数）



## 26.3 核心问题： 不可控的调度

在上面的问题中，可能出现的汇编代码是

```assembly
100 mov addr, %eax
105 add $0x1, %eax
108 mov %eax, addr
```

现在可能出现的问题为：当线程1执行完105后，发生了时钟中断，scheduler判断切换到进程2，结果进程二进行完108后再切换到进程1，这时虽然两个进程各自对counter加1，但是counter实际上只加了1（本来应该加2）

这种情况为**竞态条件** （race condition）：结果取决于代码的时间执行。由于运气不好（即在执行过程中发生的上下文切换），我们得到了错误的结果。事实上，可能每次都会得到不同的结果。因此，我们称这个结果是不确定的（indeterminate）

由于执行这段代码的多个线程可能导致竞争状态，因此我们将此段代码称为**临界区** （critical section）。临界区是访问共享变量（或更一般地说，共享资源）的代码片段，一定不能由多个线程同时执行。

- 互斥(mutual exclusion)：只有一个线程能够进入临界区。

  

存在的问题：未经控制的调度 + 共享数据 = 混乱的结果。需要原子性来解决。

## 26.4 The Wish For Atomicity(原子性愿望)

原子性的理念：all or nothing。要么全部发生，要么一个都没发生。有时将多个操作打包为一个原子性操作的行为叫做transcation。



## 26.5 还有问题

另一个存在的问题：相互等待。例如两个线程相互交互，共享一个变量。一个线程进行原子性操作时，另一个必须等待直到行为结束。





## 多处理器编程：从入门到放弃

1. 如何证明真的启动了多个线程？
   * 创立两个线程，每个都永远输出两个不同的字符，然后观察结果
2. 如何证明共享内存？
   * 不同线程对全局变量的修改
3. 如何知道每个线程的堆栈范围和大小
   * 不断递归直到crash，同时-输出堆栈点
4. 26.2的问题
   1. 开O1优化结果为n：O1优化将不会再每次循环更新sum，而会循环n次之后只写入sum一次
   2. 开O2结果为2n：直接优化成addq （一次给sum加n）