# note of chap 28 (lock)

并发编程最基本的问题：希望原子性的执行一系列指令，但由于单处理器的中断/多个线程在多处理器撒谎那个并发执行，原子性无法保证。

如何解决： 在临界区周围加锁，保证临界区代码你呢狗狗像单条原子指令一样执行

## 28.1 锁的基本思想

### 锁的定义
锁就是一个变量，故需要声明一个某种类型的锁变量（lock variable）才能使用，且这个锁变量时刻保存着锁的状态

锁只有两种状态：
* 可用的(available / unlocked / free)，代表没有线程持有该锁
* 被占用的(acquired / locked / held)，代表有一个线程持有锁，正处于临界区

锁变量中可以保存其他的信息，比如持有锁的线程，或请求获取锁的线程队列，但这些信息应该对锁的使用者不可见

### 上锁 解锁
* lock()尝试获取锁，如果没有其他线程持有锁（即锁是可用的），该线程会获得锁，进入临界区，这个线程被称为锁的持有者（owner）。如果其他线程此时调用lock()企图获得同一把锁，那么直到持有者释放这把锁之前此次调用都不会返回。这样就可以阻止其他线程进入临界区。
* 当持有者调用unlock()时，锁就再次可用。如果没有其他线程在等锁，那么锁就被标记为可用(free)。否则，等待的线程中会（最终）有一个注意到锁的状态发生变化，获得它并进入临界区。


锁为程序员提供了最小程度的调度控制。我们把线程视为程序员创建的实体,但是被
操作系统调度,具体方式由操作系统选择。锁让程序员获得一些控制权。通过给临界区加
锁,可以保证临界区内只有一个线程活跃。锁将原本由操作系统调度的混乱状态变得更为
可控。

### Pthread 锁

POSIX标准库提供的锁叫做mutex（互斥锁），提供线程之间的互斥。如果一个线程处于临界区，它（线程）就能阻止其他线程进入临界区，直到它（线程）完成了临界区的任务并退出。

POSIX允许上锁时传入一个锁变量，这样就可以使用不同的锁来保护不同的变量。这样做的好处是可以增加并发性：不需要一把大锁锁住所有的临界区（coarse-grained strategy)，多把锁可以让更多的线程同时处于上锁的区间(fine-grained approach)。

## 28.4 评价锁
1. 锁能否完成它的基本任务，即提供互斥
2. 公平性：是否有竞争锁的线程会饿死，一直无法获得锁
3. 性能：使用锁之后增加的时间开销
   * 没有竞争的情况下：只有一个线程抢锁、释放锁的开支如何？
   * 一个CPU多个线程竞争，性能如何
   * 多个CPU，多个线程竞争时的性能

### 28.5 控制中断
定义： 上锁——关中断，解锁——开中断

在**单处理器系统**中，通过关闭中断，我们可以处于临界区中的代码不被干扰，因此它的执行是原子的。

优点： 简单，正确性显然

**缺点**：
   1. 开、关中断要求允许程进行特权操作，OS必须要信任这个机制不被滥用。（但是很可能出麻烦，比如独占CPU，死循环后OS无法得到控制，只能重启）
   2. 不支持多处理器
   3. 关闭中断导致中断丢失，可能会导致严重的系统问题（磁盘完成了读取请求，但CPU错失了这一信息）
   4. 效率低

因此，关闭中断仅在有限的环境下，例如原始的互斥条件下使用。在OS中这样的用法是可行的，因为OS肯定会信任自己并允许自己进行特权操作。

#### 软件实现互斥





