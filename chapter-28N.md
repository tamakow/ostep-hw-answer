# note of chap 28 (lock)

并发编程最基本的问题：希望原子性的执行一系列指令，但由于单处理器的中断/多个线程在多处理器撒谎那个并发执行，原子性无法保证。

如何解决： 在临界区周围加锁，保证临界区代码你呢狗狗像单条原子指令一样执行

### 1. 锁的定义
锁就是一个变量，故需要声明一个某种类型的锁变量（lock variable）才能使用，且这个锁变量时刻保存着锁的状态

锁只有两种状态：
    * 可用的(available / unlocked / free)，代表没有线程持有该锁
    * 被占用的(acquired / locked / held)，代表有一个线程持有锁，正处于临界区

锁变量中可以保存其他的信息，比如持有锁的线程，或请求获取锁的线程队列，但这些信息应该对锁的使用者不可见

### 2. 

