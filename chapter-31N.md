# note of chapter 31(信号量)

## 信号量的定义
信号量(semaphore)是一个能够用两种方式操纵的整数。在POSIX标准中，这两种函数是sem_wait()和sem_post()。使用信号量前必须要进行初始化，如
```c
#include <semaphore.h>
sem_t s;
sem_init(&s, 0, 1);
```

其中申明了一个信号量s,通过第三个参数,将它的值初始化为1。sem_init()的第二个参数为0,表示信号量是在同一进程的多个线程共享的。

信号量初始化后，就可以调用上面的两个操作来控制它了。两个函数的功能如下：
```c
int sem_wait(sem_t &s) {
  // decrement the value of semaphore s by one
  // wait if value of semaphore s is negative
}

int sem_post(sem_t &s) {
  // increment the value of semaphore s by one
  // if there are one or more threads waiting, wake one
}
```
sem_wait()要么立刻返回(调用 sem_wait()
时,信号量的值大于等于 1),要么会让调用线程挂起,直到之后的一个 post 操作。

sem_post()不等待任何条件。它直接增加信号量的值,如果有等待线程,唤醒其中一个。

当信号量的值为负数时，（绝对值）等于正在等待的线程的数量。

## 二值信号量

### 用信号量作为锁
这里假设信号量函数已经保证了原子性

```c
sem_t m;
sem_init(&m, 0, 1); // 为什么设置为1

sem_wait(&m);
// critical section here
sem_post(&m);
```
为什么初始值设置为1？  
当线程0进入临界区时，信号量降为0；如果线程1企图进入临界区，信号量会降为-1，线程1进入睡眠状态。线程0退出临界区时，信号量自增并唤醒等待的线程1，最后线程1退出，信号量恢复为1。


由此，信号量可以当作锁来使用，而锁只有空闲、占用两种状态，因此这个信号量又被称为二元信号量(binary semaphore)。


## 信号量作为条件变量
信号量可用于等待其他进程，代码如下：
```c
sem_t s;

void *child(void *arg) {
  // do something
  sem_post(&s); // signal here: child is done
  return NULL;
}

int main(int argc, char *argv[]) {
  sem_init(&s, 0, 0); // 为什么初始化为0？
  // do something
  pthread_t c;
  pthread_create(&c, NULL, child, NULL);
  sem_wait(&s); // wait here for child
  // do something
  return 0;
}
```
* 父进程继续执行，调用sem_wait()，信号量变为-1并进入睡眠；此时子进程开始执行。子进程执行结束后唤醒父进程，父进程继续执行。
* 子进程直接执行，结束后信号量变为1。之后父进程继续执行，将信号量自减为0，无等待过程。

## 生产者/消费者问题
第一种尝试使用信号量解决此问题的代码使用了两个信号量：empty与full，线程通过这两个信号量来指示缓冲区为空或为满。
见图31.5 + 图 31.6

生产者首先等待缓冲区为空，再往里面放商品；而消费者首先等待缓冲区满，然后再消费商品。首先假设缓冲区只能放1个商品，即MAX = 1。

消费者消费时，首先等待full信号，然后消费一个商品，将empty减为-1，最后进入睡眠状态等待full信号，符合要求。

生产者生产时，先等待empty信号，开始生产，先将empty修改为0，然后生产一个商品，最后修改full的值为0，唤醒消费者。

此时会出现两种情况：如果生产者继续执行，就会循环并执行P1行的代码，等待empty信号并进入睡眠。否则，消费者先开始执行，发现此时缓冲区已满，消费商品。两种情况的行为都符合预期。

但如果缓冲区大小大于1（比方说10），且有多个生产者、消费者，就会出现竞争。（书中提示：注意put()和get()的代码）两个生产者$P_a$和$P_b$乎同时调用了put()，那么就有机会这两个线程往相同的内存写入了值，导致最后只生产了一个商品。详细的解释：$P_a$知道没有商品，所以它要往0号位填充商品，但此时被$P​_b$打断，$P_b$也往0号位生产商品，最后就两个生产者只生产了一个商品。）

解决方法：添加互斥锁。图31.7给生产、消费上了互斥锁，但却导致了新的问题：死锁。如果消费者C上互斥锁后发现没有商品，它就会等待full信号，但此时等待并没有解开互斥锁。随后生产者P被唤醒，永远无法获得互斥锁，C也永远无法获得full信号。

解决方案：先等信号，再上锁。（减少锁的作用域）

Understand it now; use it later. You will thank us for years to come. Or at least, you will thank us when the same question is asked on the ﬁnal exam.

正确的方案在图31.8

## 读写锁(Reader-Writer Locks)

我们希望能有一种更加灵活的上锁方式：不同的数据操作需要不同的锁。例如，可以插入和读取的链表在读取时只需要保证没有插入操作即可，这样就可以同时进行多个读操作。这种锁被称为reader-write lock。

当一个线程想要获得第一把读锁时，它同时会获取写锁，直到它结束后才会释放写锁。这样，如果有线程想要获得写锁，就必须等待所有的读线程退出临界区。

读写锁在公平性上存在巨大的问题：读线程能够轻松的阻塞写线程。在效率方面，读写锁通常带来巨大额外开销，反而使得性能不如普通互斥锁。

具体实现见图31.9

## 哲学家吃饭问题
问题的基本内容：5个哲学家围绕桌子而坐，相邻哲学家之间有一把叉子。当哲学家思考时，他不需要叉子；但当他们吃饭时，需要左手边和右手边的**两把**叉子。叉子的竞争和可能出现的同步问题使得吃饭问题在并发编程领域中有研究意义。

对于每个哲学家，他的行为构成循环：
```c
while (1) {
  think();
  getforks();
  eat();
  putforks();
}
```

这个问题的关键难点在于如何保证getforks()和putforks()不出现死锁、没有哲学家吃不到饭饿死，并且还要保证高并发性（尽可能让更多的哲学家同时吃饭）。

在解决问题前，需要定义两个简单的辅助函数：

```c
int left(int p)  { return p; }
int right(int p) { return (p + 1) % 5; }
```
如果哲学家 p 希望用左手边的叉子,他们就调用 left(p)。类似地,右手边的叉子就用right(p) 

同时，对每个叉子有一个信号量：sem_t forks[5]。

### 有问题的尝试
每个信号量都初始化为1,那么按照图31.11一样简单的使用sem_wait 和 sem_post  

解决思路：为了拿到餐叉,我们依次获取每把餐叉的锁——先是左手边的,然后是右手边的。结束就餐时,释放掉锁。

很简单，致命问题是死锁。假设每个哲学家都拿到了左手边的餐叉,他们每个都会阻塞住,并且一直等待另一个餐叉。具体来说,哲学家 0 拿到了餐叉 0,哲学家 1 拿到了餐叉 1,哲学家 2 拿到餐叉 2,哲学家 3 拿到餐叉 3,哲学家 4 拿到餐叉 4。所有的餐叉都被占有了,所有的哲学家都阻塞着,并且等待另一个哲学家占有的餐叉。

#### 解决方案
解决方案：打破依赖（Dijkstra的解决方法）。假设最高编号的哲学家（4号）先拿右手边的叉子，其他人都先拿左手边的叉子  
```c
void getforks() {
  if (p == 4) {
    sem_wait(forks[right(p)]);
    sem_wait(forks[left(p)]);
  } else {
    sem_wait(forks[left(p)]);
    sem_wait(forks[right(p)]);
  }
}
```
这样就没有可能哲学家相互等待造成死锁了。类似的问题包括抽烟者问题、睡觉的理发师问题等。

## 如何实现信号量
可以用锁和条件变量实现信号量（山寨版本）
见图31.12

## 一些tips
<font color='red'>
小 心 泛 化
</font>
（我们可以把信号量当作锁和条件变量的泛化。但这种泛化有必要吗?考虑基于信号量去实现条件变量的难度,可能这种泛化并没有你想的那么通用。）